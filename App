import java.util.*;

// Product class to represent items in the tech shop
class Product {
    private int id;
    private String name;
    private double price;

    public Product(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "Product{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
}

// TechShop class to simulate a tech shop using various data structures
public class TechShopSimulation {

    public static void main(String[] args) {
        // Using simple array
        Product[] productsArray = new Product[10]; // Array size of 10 for storing products

        // Using ArrayList
        List<Product> productsList = new ArrayList<>();

        // Using LinkedList
        LinkedList<Product> productsLinkedList = new LinkedList<>();

        // Using Binary Search Tree
        BinarySearchTree<Product> productsTree = new BinarySearchTree<>();

        // Using Stack
        Stack<Product> productsStack = new Stack<>();

        // Adding products to different data structures
        addProducts(productsArray, productsList, productsLinkedList, productsTree, productsStack);

        // Simulating operations
        simulateOperations(productsArray, productsList, productsLinkedList, productsTree, productsStack);
    }

    // Method to add products to each data structure
    private static void addProducts(Product[] array, List<Product> list, LinkedList<Product> linkedList,
                                    BinarySearchTree<Product> tree, Stack<Product> stack) {
        // Adding products to array
        array[0] = new Product(1, "Laptop", 999.99);
        array[1] = new Product(2, "Tablet", 299.99);
        array[2] = new Product(3, "Smartphone", 699.99);

        // Adding products to ArrayList
        list.add(new Product(4, "Keyboard", 49.99));
        list.add(new Product(5, "Mouse", 19.99));

        // Adding products to LinkedList
        linkedList.add(new Product(6, "Headphones", 79.99));
        linkedList.add(new Product(7, "Monitor", 299.99));

        // Adding products to Binary Search Tree
        tree.insert(new Product(8, "Printer", 199.99));
        tree.insert(new Product(9, "Router", 149.99));

        // Adding products to Stack
        stack.push(new Product(10, "External Hard Drive", 129.99));
        stack.push(new Product(11, "USB Drive", 19.99));
    }

    // Method to simulate operations on each data structure
    private static void simulateOperations(Product[] array, List<Product> list, LinkedList<Product> linkedList,
                                           BinarySearchTree<Product> tree, Stack<Product> stack) {
        // Accessing elements from array
        System.out.println("Products in array:");
        for (Product product : array) {
            if (product != null) {
                System.out.println(product);
            }
        }

        // Accessing elements from ArrayList
        System.out.println("\nProducts in ArrayList:");
        for (Product product : list) {
            System.out.println(product);
        }

        // Accessing elements from LinkedList
        System.out.println("\nProducts in LinkedList:");
        for (Product product : linkedList) {
            System.out.println(product);
        }

        // Accessing elements from Binary Search Tree (inorder traversal)
        System.out.println("\nProducts in Binary Search Tree (inorder traversal):");
        tree.inorder();

        // Accessing elements from Stack
        System.out.println("\nProducts in Stack (LIFO order):");
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
    }

    // Binary Search Tree class for managing products
    static class BinarySearchTree<T extends Comparable<T>> {
        private Node<T> root;

        public BinarySearchTree() {
            this.root = null;
        }

        public void insert(T data) {
            this.root = insertRecursive(root, data);
        }

        private Node<T> insertRecursive(Node<T> current, T data) {
            if (current == null) {
                return new Node<>(data);
            }

            if (data.compareTo(current.data) < 0) {
                current.left = insertRecursive(current.left, data);
            } else if (data.compareTo(current.data) > 0) {
                current.right = insertRecursive(current.right, data);
            }

            return current;
        }

        public void inorder() {
            inorderRecursive(root);
        }

        private void inorderRecursive(Node<T> node) {
            if (node != null) {
                inorderRecursive(node.left);
                System.out.println(node.data);
                inorderRecursive(node.right);
            }
        }

        private static class Node<T> {
            private T data;
            private Node<T> left;
            private Node<T> right;

            public Node(T data) {
                this.data = data;
                this.left = null;
                this.right = null;
            }
        }
    }
}
